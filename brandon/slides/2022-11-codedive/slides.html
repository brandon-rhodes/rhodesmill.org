<!DOCTYPE html>

<meta charset="utf-8">

<style>
@font-face {
  font-family: 'Gentium 1';
  src: url('/fonts/GentiumPlus-Regular.ttf');
}
@font-face {
  font-family: 'Gentium 1';
  font-style: italic;
  src: url('/fonts/GentiumPlus-Italic.ttf');
}
@font-face {
  font-family: 'Gentium 2';
  src: url('/fonts/gentium-basic-v11-latin-ext_latin-regular.woff');
}
@font-face {
  font-family: 'JetBrains Mono';
  src: url('/fonts/JetBrainsMono-Regular.ttf');
}
html {
 background-color: #ddd; line-height: 1.2;
 font-size: 48px; font-family: 'Gentium 1', 'Gentium 2';
}
body {margin: 0}
.slide {
 display: table; margin-bottom: 12px; width: 1280px; min-height: 720px;
}
.slide > div {
 display: table-cell; vertical-align: middle;
}
.slide:before {
 position: absolute; left: 0; right: 0; width: 1280px; height: 720px;
 background-color: white; content: " "; z-index: -1;
 //border: 1px solid black;
}
.slide > div > p,
.slide > div > pre {
 padding-left: 36px; padding-right: 36px;
}
.slide > div > ul {
 padding-left: 72px; padding-right: 36px;
}
.slide > div > p {
// margin-left: auto; margin-right: auto;
 text-align: center;
}
//.slide > div > img {object-fit: contain; object-position: 50% 50%;}
.slide p img {width: 100%; height: 600px; object-fit: contain}
.slide > div > img {display: block; margin-left: auto; margin-right: auto}
.patterns {font-size: 42px}
.patterns td {width: 10em}
pre {line-height: 1; text-align: center}
code {
 display: inline-block; text-align: left;
 font-family: 'JetBrains Mono'; font-size: 80%;
}

.qmark {background-color: #FFDB58}
.plus {font-weight: bold; background-color: #ADD8E6}
.tilde {text-decoration: line-through}
.one {background-color: #def}
.two {background-color: #ADD8E6}
.three {background-color: #efd}

.timer {margin: 10px}
.emergency {color: white; background-color: red}
</style>

<p><strong>The Classic Design Patterns:<br> Where Are They Now?</strong><br> <br> Brandon Rhodes<br> code::dive 2022<br> Wrocław, Poland</p>
<img src="design-patterns-book-cover.jpg">

<p><em>Design Patterns</em> (1994)<br> <br> Book on Object Oriented programming<br> <br> by Erich Gamma, Richard Helm,<br> Ralph Johnson, and John Vlissides<br> (the ‘Gang of Four’)</p>
<p>It described 23 ‘design patterns’<br> that had become common solutions for<br> the problems with Object Oriented languages</p>
<p>The goal for this talk:<br> <br> To make a brief survey of the 23 patterns<br> to learn which patterns from 1994 are<br> still relevant to programming today</p>
<p><em>Limitations of this talk —</em></p>
<ul>
<li>It will have to cover 23 patterns in one hour</li>
<li>It reflects my experience programming, not yours</li>
<li>There will not be much time for nuance</li>
<li>We will have to ignore several corner cases</li>
<li>It won’t be entirely fair towards the Visitor Pattern</li>
</ul>
<p>But that’s okay!<br> <br> It’s fine if <em>your</em> list of relevant patterns<br> is different than mine by the time we finish the talk<br> <br> The goal is for these old patterns to help<br> us reflect on our own practices today</p>
<p>Happily, the book is online,<br> so you can review the patterns yourself<br> later to develop your own opinions<br> if you don’t like mine<br> <br> https://www.cs.unc.edu/~stotts/GOF/hires/contfso.htm</p>
<p>So here we go</p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=plain>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=plain>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=plain>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=plain>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=plain>Strategy
<tr><td><td><td class=plain>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<p>First, let’s cross off the patterns that aren’t relevant if your programming language offers first-class functions.</p>
<p>What are first-class functions? <br>Functions that can be: <br> <br>• Passed as an argument <br>• Placed in a data structure</p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=plain>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=plain>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=plain>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=plain>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=plain>Strategy
<tr><td><td><td class=plain>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=qmark>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=qmark>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=qmark>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=qmark>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=qmark>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<p>Factory Method — Subclass <code>Application</code>, override a method<br> <img src="fmeth049.gif"></p>
<p>Not only does that sound hopelessly awkward <em>today,</em> but even <em>Design Patterns</em> itself, back in 1994, offered a better approach! Two chapters earlier: the Abstract Factory.</p>
<pre><code># The Abstract Factory

class MyDocumentFactory(DocumentFactory):
    def build():
        return MyDocument()

f = MyDocumentFactory()
a = Application(f)
</code></pre>
<p>Q: Why prefer the Abstract Factory to the Factory Method?<br> <br> A: Because of a fundamental design principle from the Introduction chapter of the <em>Design Patterns</em> book:<br> <br> <em>Favor object composition over class inheritance.</em><br></p>
<pre><code># What is ‘composition’? You have ‘composed’
# two objects when you give one of them
# a reference to the other:

class MyDocumentFactory(DocumentFactory):
    def build():
        return MyDocument()

f = MyDocumentFactory()  # object 1
a = Application(f)       # object 2
</code></pre>
<p><em>Favor object composition over class inheritance.</em><br> <br>Why? <br> <br>Because putting objects together dynamically <br>at <strong>runtime</strong> is more flexible than writing <br>extra classes at <strong>compile</strong> time</p>
<p>Factory Method? Class inheritance.<br> Abstract Factory? Object composition.<br> <br> Abstract Factory &gt; Factory Method</p>
<p>So, why did <em>Design Patterns</em> include<br> the Factory Method if a better<br> alternative already existed?</p>
<p>Because they wanted the book to be a complete catalog<br> of all common Object Oriented patterns—<br> <br> they did <em>not</em> limit themselves to best practices.</p>
<p>And the Factory Method,<br> despite its awkwardness,<br> was in <em>widespread</em> use.<br> <br> ‘Factory methods pervade toolkits and frameworks.<br> MacApp … ET++ … Unidraw … Smalltalk-80 … Orbix ORB’</p>
<p>Abstract Factory <br>Factory Method<br> <br> But neither one is a pattern we use in modern languages</p>
<pre><code># First-class functions? Pass a function.

def build_document():
    return MyDocument()

a = Application(build_document)

# First-class types? Just pass the class!

a = Application(MyDocument)
</code></pre>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=qmark>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=qmark>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=qmark>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=qmark>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=qmark>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=qmark>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=qmark>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=qmark>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<p>Template Method — if <code>Application</code> needs you to give it three procedures, it should force you to write a subclass<br> <img src="tmeth007.gif"></p>
<p><em>Favor object composition over class inheritance.</em><br> These three methods should live on a separate class.<br> <img src="tmeth007.gif"></p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=qmark>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=qmark>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=qmark>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=qmark>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=qmark>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<p>The Prototype Pattern<br> <br> Example: Imagine we are writing a music composition<br> app that wants to let users create four kinds of object.</p>
<pre><code># The objects are of different classes.
# Some of their constructors need arguments.

Rest()        # quarter rest
Note(1)       # whole note
Note(2)       # half note
Note(4)       # quarter note
</code></pre>
<p>How could you explain to, say, a menu widget<br> how to create these objects when menu items are selected?</p>
<pre><code># In a modern language, you would
# just pass a data structure

menu.add_actions([
    (&#39;Rest&#39;, Rest),
    (&#39;Whole note&#39;, Note, 1),
    (&#39;Half note&#39;, Note, 2),
    (&#39;Quarter note&#39;, Note, 4),
])
</code></pre>
<p>Q: But what if your language isn’t that powerful?<br> Are you going to need as many factories<br> as kinds of object you want to create?<br> <br> <code>build_rest()</code><br> <code>build_whole_note()</code><br> <code>build_half_note()</code><br> <code>build_quarter_note()</code></p>
<p>A: The Prototype Pattern says, No! <br>Simply create examples of the four objects, <br>and give them each a <code>clone()</code> method</p>
<pre><code># The Prototype Pattern

r = Rest()
r.clone() → another Rest

n = Note(1)
n.clone() → another Note of length 1

n = Note(2)
n.clone() → another Note of length 1/2

n = Note(4)
n.clone() → another Note of length 1/4
</code></pre>
<pre><code># Thanks to the Prototype Pattern’s `.clone()`
# method, we can give plain object instances
# to the menu instead of factories.

menu.add_action(&#39;Rest&#39;, Rest())
menu.add_action(&#39;Whole note&#39;, Note(1))
menu.add_action(&#39;Half note&#39;, Note(2))
menu.add_action(&#39;Quarter note&#39;, Note(4))
</code></pre>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=qmark>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=qmark>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=qmark>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<p><em>Singletons:</em> those annoying global objects that code needs access to but you don’t want to pass everywhere</p>
<p>Do we need Singletons? <em>Sometimes. Maybe.</em><br> That’s a big topic of its own.</p>
<p>But, do we need the Singleton Pattern, where the <em>class itself</em><br> is contorted to force its use as a Singleton? <br> <img src="singl014.gif"></p>
<p>No!</p>
<pre><code># Just write the class normally,
# build a single instance, and provide
# a global name or a global function
# that returns that instance.

import logging

root = logging.getLogger()
</code></pre>
<p>Why avoid the Singleton Pattern?<br> <br> One reason: testing becomes <em>hard</em> and tests<br> of the singleton become <em>coupled</em> if you really<br> truly can’t create a fresh instance,<br> so the tests are having to share)</p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=qmark>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<p>The Strategy Pattern<br> <br> Example: What if an object needs to be given <br>a specific paragraph-breaking routine at <br>runtime, out of 3 that are available?</p>
<p>Strategy Pattern<br> <br> Put the 3 versions of the routine<br> in 3 single-method classes, build an<br> instance of each, and pass them as<br> constructor arguments at runtime</p>
<p>Strategy Pattern<br> <img src="strat011.gif"></p>
<p>We can solve this more simply <br> <br>In any modern language, you solve this problem by <em>just writing 3 functions,</em> and passing one in as an argument.<br> <br> <em>Done</em></p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=qmark>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<p>In powerful modern languages, those six patterns disappear because they aren’t needed.</p>
<pre><code> 23
- 6
___
 17
</code></pre>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=plain>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=plain>Visitor
</table>

<p>There are two patterns<br> that are also <em>disappearing</em><br> from our code, but it’s because<br> they are so useful—they are now<br> getting <strong>built into</strong> our languages.</p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=qmark>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=qmark>Visitor
</table>

<p>Both of them involve a <em>producer</em> object<br> which is going to build or retrieve items and<br> a <em>consumer</em> object that wants to iterate over them</p>
<ul>
<li>Iterator Pattern
<ul>
<li><em>producer</em> offers a callback method, like <code>next()</code></li>
<li><em>consumer</em> loops, calling <code>next()</code> over and over <br><br></li>
</ul></li>
<li>Visitor Pattern
<ul>
<li><em>producer</em> iterates across a data structure</li>
<li><em>consumer</em> offers one (or more) callback methods</li>
</ul></li>
</ul>
<p>In legacy languages,<br> you have to choose one approach or the other. <br><br> Either way, <em>someone’s</em> class has to<br>suffer callback-style programming.</p>
<p>Solution: generators <br><br> (CLU 1975, Icon 1977, Python 2001, then C#, JS, Ruby)</p>
<pre><code>class Ten:             # Before generators,
    n = 0              # you had to write up the
                       # Iterator Pattern yourself
    def next(self):
        self.n += 1
        if self.n &gt; 10:
            raise StopIteration
        return self.n
</code></pre>
<pre><code>def ten():             # After generators
    n = 0
    while n &lt; 10:
        n += 1
        yield n
</code></pre>
<p>Each time the consumer <em>asks</em> for an item,<br> the producer runs enough code to reach its<br> next <code>yield</code> and <em>deliver</em> the item.<br> <br> So the consumer’s requests for more<br> items gradually cause the producer<br> to run all the way to completion.</p>
<pre><code># So *both* the producer and consumer
# can be written with normal control flow
# statements like `if` `for` and `while`;
# neither is forced to endure callbacks.

def producer(...):
    for item in ...:
        yield item

def consumer(...):
    for item in producer(...):
        ... # operate on `item`
</code></pre>
<pre><code># Passing a producer to a consumer works
# exactly as though you had implemented
# the Iterator Pattern by hand.

p = producer()
result = consumer(p)
</code></pre>
<p><em>except—</em></p>
<p>Don’t <em>actually</em> let a consumer talk to a producer</p>
<pre><code># If you have the consumer drive the
# producer directly, your main thread
# loses control.

p = producer()
result = consumer(p)
</code></pre>
<img src="Toppledominos.jpg">

<pre><code>p = producer()
result = consumer(p)
</code></pre>
<pre><code># Instead, run the producer to completion
# and save the output in a plain flat data
# structure: a list.

plain_list = []
for item in producer():
    plain_list.append(item)

# Then, pass the list to the consumer.

result = consumer(plain_list)
</code></pre>
<p>This idea sounds silly when we’re only talking<br> about one producer and one consumer, but as<br> an application grows, you should always prefer<br> shallow call stacks to deep ones</p>
<p>It’s a good day when you can draw a<br> bright line across your code and say,<br> <br> ‘everything above this line has <em>finished</em><br> <em>running</em> and the only thing crossing this<br> line is a simple inert data structure’</p>
<pre><code>plain_list = []
for item in producer():
    plain_list.append(item)

# -------- bright line --------

result = consumer(plain_list)
</code></pre>
<p>Why?</p>
<p>Because <strong>data</strong> is <em>easier</em> to<br> reason about than <strong>control flow</strong></p>
<p><em>The Mythical Man-Month</em> by Fred Brooks (1975):<br> <br> “Show me your <em>flowchart</em><br> and conceal your tables,<br> and I shall continue to be mystified.<br> <br> Show me your <em>tables</em>,<br> and I won’t usually need your flowchart;<br> it’ll be obvious.”</p>
<p>♥ Your Data</p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=qmark>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=qmark>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<pre><code> 23
- 8
___
 15
</code></pre>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=plain>Memento
<tr><td><td class=plain>Proxy<td class=plain>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=qmark>Memento
<tr><td><td class=qmark>Proxy<td class=qmark>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<p>Proxy — sends method calls across the network<br> Memento — saves object state as a binary string<br> Observer — object offer subscriptions to its changes</p>
<p>Let’s look at their <em>sins</em></p>
<p>Proxy Pattern — <em>hides</em> how data is passed across the network<br> Memento Pattern — <em>hides</em> how data is persisted to disk<br> Observer Pattern — <em>scatters</em> data rather than <em>unifying</em> it</p>
<p>♥ Your Data</p>
<p><s>Proxy Pattern</s> <br> <br> <br>Network APIs between your services should use <br>a data format <em>you</em> understand (JSON, Protobuf, CSV) <br>and be <em>hand-crafted</em> to make sense over <br>a high-latency channel</p>
<p>Good object methods: small, orthogonal, numerous <br>Good remote procedures: comprehensive, aggregate, few</p>
<p><br>Example: a class might offer getters and setters <br>for all of its 11 instance variables; but a network <br>call would probably return all 11 at once, <br>and set as many as you want to provide</p>
<p><s>Memento Pattern</s><br> <br> Data should be persisted in a format that’s<br> <em>independent</em> of your programming language and<br> that you can access directly using other tools<br> <br> (JSON, Protobuf, CSV, MySQL, Postgres)</p>
<p><s>Observer Pattern</s> <br> <br>Should we really be building forests of objects <br>that are subscribed to each other’s state changes? <br> <br>No! <br> <br>Look on YouTube for Facebook talks about React.</p>
<p>React is the most popular JS library today <br> <br><s>jQuery</s> <br>React</p>
<pre><code>          Clicks, Keystrokes, Server events
       ↙
State
(data) ↘
          View
</code></pre>
<p>So, React makes a <em>data structure</em> <br>the foundation of your application</p>
<p>Proxy Pattern<br> Memento Pattern<br> Observer Pattern<br> <br> All three of these patterns<br> fail to put data <em>first</em></p>
<p>♥ Your Data</p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=qmark>Memento
<tr><td><td class=qmark>Proxy<td class=qmark>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<pre><code> 23
-11
___
 12
</code></pre>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=plain>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=plain>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=plain>Mediator
<tr><td><td class=plain>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=plain>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=qmark>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=qmark>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=qmark>Mediator
<tr><td><td class=plain>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=qmark>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<p>Bridge — one real-world object, but <em>two</em> classes<br> <img src="bridg100.gif"></p>
<p>Decorator — a wrapper with the same interface as the object<br> <img src="decor066.gif"></p>
<p>Decorator — a wrapper with the same interface as the object<br> <img src="decor065.gif"></p>
<p>Mediator — extra class to take action when widgets update<br> <img src="media034.gif"></p>
<p>State — replace if-else stacks with separate objects<br> <img src="state-eg.gif"></p>
<p>Bridge Pattern<br> Decorator Pattern<br> Mediator Pattern<br> State Pattern<br> <br> Q: What do these have in common?</p>
<p>Bridge Pattern<br> Decorator Pattern<br> Mediator Pattern<br> State Pattern<br> <br> A: They all <em>break</em> the Object Oriented assumption that <em>one</em> real-world object should become <em>one</em> object in your code.</p>
<pre><code>                Bridge ← class
 Decorator ← Decorator ← class
              Mediator ← class
                         class → State
</code></pre>
<p>Bridge Pattern<br> Decorator Pattern<br> Mediator Pattern<br> State Pattern<br> <br> These four classes all begin a <em>disassembly</em> of Object Orientation, and start using classes to organize <em>procedures</em> into <em>layers</em> rather than to represent <em>data</em></p>
<p>data ← objects → actions</p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=qmark>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=qmark>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=qmark>Mediator
<tr><td><td class=plain>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=qmark>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=one>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=one>Mediator
<tr><td><td class=plain>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<img src="Toppledominos.jpg">

<pre><code>                Bridge ← class
 Decorator ← Decorator ← class
              Mediator ← class
                         class → State
</code></pre>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=plain>Adapter<td class=plain>Chain of Responsibility
<tr><td class=plain>Builder<td class=one>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=one>Mediator
<tr><td><td class=plain>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=qmark>Adapter<td class=plain>Chain of Responsibility
<tr><td class=qmark>Builder<td class=one>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=one>Mediator
<tr><td><td class=qmark>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<p>Builder Pattern — provides a single object whose API builds and returns an object hierarchy for us</p>
<pre><code># Example: the matplotlib ‘Axis’ object
# provides methods for building Plot and
# Annotation objects.

import matplotlib.pyplot as plt

fig, ax = plt.subplots()
ax.plot(x, y, c=&#39;red&#39;)
ax.annotate(x[0], y[0], &#39;start&#39;)
ax.annotate(x[1], y[1], &#39;end&#39;)
</code></pre>
<p>Adapter Pattern —<br> when a class doesn’t offer the interface you need,<br> write a <em>wrapper</em> class that does, and have its<br> methods call the underlying object</p>
<p>Example: Python’s <code>socket.makefile()</code> method returns an Adapter that looks like a file object but whose <code>read()</code> and <code>write()</code> methods really call the socket’s <code>recv()</code> and <code>send()</code> methods.<br> <br> <code>adapter.read() -&gt; socket.recv()</code><br> <code>adapter.write() -&gt; socket.send()</code></p>
<p>Flyweight Pattern — small read-only data objects can be shared between object instances.</p>
<pre><code> Glyph        Glyph

 x 108        x 124
 y 10         y 10

   ↘          ↙

     CharData

     height  12
     width    8
     descent  2
</code></pre>
<p>Example: the integers −5 through 256<br> in Python are flyweight objects.<br> <br> Each time a calculation returns an integer in that range,<br> it’s the same object that gets returned each time.</p>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=qmark>Adapter<td class=plain>Chain of Responsibility
<tr><td class=qmark>Builder<td class=one>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=one>Mediator
<tr><td><td class=qmark>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=two>Adapter<td class=plain>Chain of Responsibility
<tr><td class=two>Builder<td class=one>Bridge<td class=plain>Command
<tr><td class=tilde>Factory Method<td class=plain>Composite<td class=plain>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=one>Mediator
<tr><td><td class=two>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=two>Adapter<td class=qmark>Chain of Responsibility
<tr><td class=two>Builder<td class=one>Bridge<td class=qmark>Command
<tr><td class=tilde>Factory Method<td class=qmark>Composite<td class=qmark>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=one>Mediator
<tr><td><td class=two>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<p>Composite Pattern <br>Chain of Responsibility Pattern <br>Command Pattern <br>Interpreter Pattern <br> <br>These are what I call the ‘Framework Patterns’</p>
<p>Composite — give all nodes in a hierarchy the same interface<br> <img src="compo075.gif"></p>
<p>DOM = Document Object Model</p>
<pre><code>HTML:

&lt;div&gt;
 &lt;img src=&quot;example.jpg&quot;&gt;
&lt;/div&gt;

JS:

div.tagName  → &#39;DIV&#39;
img.tagName  → &#39;IMG&#39;

div.children.length  → 1
img.children.length  → 0
</code></pre>
<p>Chain of Responsibility — in a Composite UI hierarchy,<br> pass unprocessed clicks and keystrokes up to your parent<br> <br> This is <em>universal</em> and called ‘bubbling’ in the browser</p>
<p>Command — represent user actions as a list of<br> objects that have both <code>do()</code> and <code>undo()</code> methods<br> <br> This is <em>universal</em> in browsers and GUI frameworks</p>
<p>It turns out the Command Pattern<br> is useful in other contexts!<br> <br> Example: the Django web framework’s migrations system</p>
<pre><code># Django lets you define what your database
# tables should look like using a declarative
# syntax.

from django.db import models

class Question(models.Model):
    text = models.CharField(max_length=200)
    pub = models.DateTimeField(&#39;date published&#39;)
</code></pre>
<p>As your models change, Django saves those database migrations using the Command Pattern, so you can <em>both</em> apply each migration to move forward but also ‘undo’ a migration to recover and move back.</p>
<pre><code>v1 CreateModel
   CreateModel
   AddIndex

v2 AlterModelTable
   AddField

v3 RenameField
</code></pre>
<p>Interpreter — uses the Composite Pattern to represent an Abstract Syntax Tree, and make it executable by giving each node a <code>run()</code> method.</p>
<pre><code>      &quot;n + 1&quot;

       ┌───┐
       │add│
       └───┘
       ↗   ↖
┌───────┐ ┌────────┐
│get `n`│ │return 1│
└───────┘ └────────┘
</code></pre>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=two>Adapter<td class=qmark>Chain of Responsibility
<tr><td class=two>Builder<td class=one>Bridge<td class=qmark>Command
<tr><td class=tilde>Factory Method<td class=qmark>Composite<td class=qmark>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=one>Mediator
<tr><td><td class=two>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=two>Adapter<td class=three>Chain of Responsibility
<tr><td class=two>Builder<td class=one>Bridge<td class=three>Command
<tr><td class=tilde>Factory Method<td class=three>Composite<td class=three>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=plain>Facade<td class=one>Mediator
<tr><td><td class=two>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=two>Adapter<td class=three>Chain of Responsibility
<tr><td class=two>Builder<td class=one>Bridge<td class=three>Command
<tr><td class=tilde>Factory Method<td class=three>Composite<td class=three>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=qmark>Facade<td class=one>Mediator
<tr><td><td class=two>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<p>Facade—hide a complex system behind a single API class<br> <img src="facad057.gif"></p>
<p>Problem: to qualify as a Facade Pattern,<br> an API must live on <em>only one object</em>, but<br> real-world APIs almost always use <em>several</em><br> <br> Examples: two real-world APIs, jQuery and Pandas.</p>
<pre><code># jQuery: is it a Facade? No, because each
# query returns a separate object.

var paragraphs = $(&#39;p&#39;); // jQuery object
paragraphs.find(&#39;b&#39;)     // another object
</code></pre>
<pre><code># Pandas: is its DataFrame a Facade?

filename = &#39;transactions.csv&#39;
df = pd.read_csv(filename)    # DataFrame
print(df.size)
print(df.columns)

# No, because interacting with a
# specific column returns a `Series`.

name = df[&#39;Name&#39;]             # Series
amount = df[&#39;Amount&#39;]         # Series
</code></pre>
<p>Facade: 1 object<br> Real APIs: <em>n</em> objects</p>
<p>Also, the <em>Design Patterns</em> example of a Facade<br> provides no access to the underlying subsystem.<br> <br> But real-world APIs are usually happy<br> to let you access the lower level directly.</p>
<pre><code># jQuery:

paragraphs[0]  # raw browser `Element`!

# Pandas:

amount.values()  # raw NumPy array!
</code></pre>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=two>Adapter<td class=three>Chain of Responsibility
<tr><td class=two>Builder<td class=one>Bridge<td class=three>Command
<tr><td class=tilde>Factory Method<td class=three>Composite<td class=three>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=qmark>Facade<td class=one>Mediator
<tr><td><td class=two>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<p>So we’ve made it—we’ve completed our survey.</p>
<ul>
<li>8 patterns: useless if you have 1st-class functions</li>
<li>2 patterns: language built-ins</li>
<li>4 patterns: decompose big classes, but are obscure</li>
<li>3 patterns: small but useful</li>
<li>4 patterns: <em>huge</em> and dominate our frameworks</li>
<li>1 pattern: ambitious but fatally limited</li>
</ul>
<table class=patterns>
<tr><th>Creational<th>Structural<th>Behavioral
<tr><td class=tilde>Abstract Factory<td class=two>Adapter<td class=three>Chain of Responsibility
<tr><td class=two>Builder<td class=one>Bridge<td class=three>Command
<tr><td class=tilde>Factory Method<td class=three>Composite<td class=three>Interpreter
<tr><td class=tilde>Prototype<td class=one>Decorator<td class=tilde>Iterator
<tr><td class=tilde>Singleton<td class=qmark>Facade<td class=one>Mediator
<tr><td><td class=two>Flyweight<td class=tilde>Memento
<tr><td><td class=tilde>Proxy<td class=tilde>Observer
<tr><td><td><td class=one>State
<tr><td><td><td class=tilde>Strategy
<tr><td><td><td class=tilde>Template Method
<tr><td><td><td class=tilde>Visitor
</table>

<!--

TODO: pattern matching to replace the N methods of Visitor pattern
TODO: “structural” patterns ‘structure’ action, not data

-->

<script>
(function() {
 var body = document.querySelector('body');
 var a = Array.from(body.children);
 var i = 0;
 a.forEach((item) => {
  //console.log(item);
  i++;
  // var html = '<div class=slide><div><div>'
  //  + item.outerHTML
  //  + '</div></div></div>';
  var html = '<div class=slide><div>' + item.outerHTML + '</div></div>'
  //var html = '<div class=slide>' + item.outerHTML + '</div>'
  item.outerHTML = html;
 });
 console.log('Slide count:', i);
})();
</script>

<script src="../js/slides4.js"></script>

