<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Positions and Coordinates — Skyfield documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/style.css">
  </head>
  <body>
    
    <p class="motto">
      <b>Skyfield:</b>
      <a href=".">Home</a>
      •
      <a href="toc.html">Table of Contents</a>
      •
      <a href="installation.html#changelog">Changelog</a>
      •
      <a href="api.html">API Reference</a>
    </p>
    
    <div class="section" id="positions-and-coordinates">
<h1>Positions and Coordinates<a class="headerlink" href="#positions-and-coordinates" title="Permalink to this headline">¶</a></h1>
<p>Skyfield stores the locations of celestial bodies
as (<em>x,y,z</em>) vectors that it calls <em>positions.</em>
There are several kinds of celestial object
for which Skyfield can produce a position.
If there’s a particular kind of object you’re interested in,
you might want to read its documentation first,
then return here when you’re ready
to learn more about the position objects that they generate:</p>
<ul class="simple">
<li><a class="reference internal" href="planets.html"><span class="doc">Planets and their moons: JPL ephemeris files</span></a></li>
<li><a class="reference internal" href="stars.html"><span class="doc">Stars and Distant Objects</span></a></li>
<li><a class="reference internal" href="earth-satellites.html"><span class="doc">Earth Satellites</span></a></li>
<li><a class="reference internal" href="kepler-orbits.html"><span class="doc">Kepler Orbits</span></a> (comets and asteroids)</li>
</ul>
<p>You can also build a position object yourself
by providing (<em>x,y,z</em>) coordinates to a position class:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skyfield.positionlib</span> <span class="kn">import</span> <span class="n">Barycentric</span>

<span class="n">x</span> <span class="o">=</span> <span class="mf">3141.0</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">2718.0</span>
<span class="n">z</span> <span class="o">=</span> <span class="mf">5820.0</span>
<span class="n">barycentric</span> <span class="o">=</span> <span class="n">Barycentric</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
</pre></div>
</div>
<p>This document focuses
on what you can do with positions once they’ve been computed,
and on how position objects are used in Skyfield code.</p>
<div class="section" id="quick-reference">
<h2>Quick reference<a class="headerlink" href="#quick-reference" title="Permalink to this headline">¶</a></h2>
<p>For a succinct catalog of the attributes and methods
offered by Skyfield’s position classes,
follow these links to the API documentation.</p>
<ul>
<li><p class="first"><a class="reference internal" href="api.html#astronomical-positions"><span class="std std-ref">Astronomical positions</span></a></p>
<p>All the attributes and methods of the core Skyfield position classes.</p>
</li>
<li><p class="first"><a class="reference internal" href="api.html#units"><span class="std std-ref">Units</span></a></p>
<p>Skyfield’s distance, velocity, and angle classes,
which offer simple attributes like <code class="docutils literal notranslate"><span class="pre">km</span></code>
but also fancy methods like <code class="docutils literal notranslate"><span class="pre">dstr()</span></code>
that formats an angle as degrees, minutes, and seconds.</p>
</li>
</ul>
</div>
<div class="section" id="the-icrs-reference-system-and-j2000">
<span id="icrs"></span><h2>The ICRS reference system and J2000<a class="headerlink" href="#the-icrs-reference-system-and-j2000" title="Permalink to this headline">¶</a></h2>
<p>Even though Skyfield scripts often produce output
in spherical coordinates —
like right ascension and declination,
or altitude and azimuth —
Skyfield always stores positions internally
as Cartesian (<em>x,y,z</em>) vectors
oriented along the axes of the International Celestial Reference System&nbsp;(ICRS).</p>
<p>The ICRS is a higher-accuracy replacement
for the old J2000 reference system.
It’s defined using the positions of very distant quasars,
so its precision can improve each decade
as radio telescopes measure quasar positions ever more accurately.</p>
<p>If you want to interact directly with ICRS (<em>x,y,z</em>) coordinates,
here is where its axes point:</p>
<ul class="simple">
<li><em>x-axis</em> — Aims at 2000&nbsp;January&nbsp;1 position of the Vernal Equinox,
which is defined more technically
as the ascending node of the ecliptic on the mean celestial equator.
Ancient astronomers called this “the first point of Ares”
but precession has gradually shifted it into the constellation Pisces.</li>
<li><em>y-axis</em> — Aims at the point 90° east of the Vernal Equinox
along the celestial equator,
which lies south of Betelgeuse and a few degrees east of Orion’s belt.</li>
<li><em>z-axis</em> — Aims at the North Celestial Pole.</li>
</ul>
<p>The ICRS axes are within 0.02 arcseconds of the old J2000 axes,
so many scripts simply treat J2000 coordinates
as modern ICRS coordinates.</p>
</div>
<div class="section" id="barycentric-astrometric-apparent">
<h2>Barycentric → Astrometric → Apparent<a class="headerlink" href="#barycentric-astrometric-apparent" title="Permalink to this headline">¶</a></h2>
<p>The most common calculations in Skyfield
produce a succession of three (<em>x,y,z</em>) positions,
one for the observer and two for the body being observed.
The three positions can be hard to find in Skyfield code
because they are often created and used
without ever being given a name.
As an example,
let’s use an <a class="reference internal" href="planets.html"><span class="doc">ephemeris</span></a>
to compute a geocentric position for Mars:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skyfield.api</span> <span class="kn">import</span> <span class="n">load</span>

<span class="n">ts</span> <span class="o">=</span> <span class="n">load</span><span class="o">.</span><span class="n">timescale</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">utc</span><span class="p">(</span><span class="mi">1980</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">planets</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="s1">&#39;de421.bsp&#39;</span><span class="p">)</span>
<span class="n">earth</span><span class="p">,</span> <span class="n">mars</span> <span class="o">=</span> <span class="n">planets</span><span class="p">[</span><span class="s1">&#39;earth&#39;</span><span class="p">],</span> <span class="n">planets</span><span class="p">[</span><span class="s1">&#39;mars&#39;</span><span class="p">]</span>

<span class="c1"># Three positions in a single line of code!</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">earth</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">mars</span><span class="p">)</span><span class="o">.</span><span class="n">apparent</span><span class="p">()</span><span class="o">.</span><span class="n">distance</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mars is </span><span class="si">{:.2f}</span><span class="s1"> au from Earth&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">au</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Mars is 0.97 au from Earth
</pre></div>
</div>
<p>By chaining together four different methods,
the line that computes the distance <code class="docutils literal notranslate"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">…</span></code>
creates and discards three different Skyfield positions
in a single line of code!
To learn about them,
the beginner will probably need to slow up and re-write that line
so each object is assigned a separate name:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The “d =” line from the previous example,</span>
<span class="c1"># rewritten to give each position a name.</span>

<span class="n">barycentric</span> <span class="o">=</span> <span class="n">earth</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">astrometric</span> <span class="o">=</span> <span class="n">barycentric</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">mars</span><span class="p">)</span>
<span class="n">apparent</span> <span class="o">=</span> <span class="n">astrometric</span><span class="o">.</span><span class="n">apparent</span><span class="p">()</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">apparent</span><span class="o">.</span><span class="n">distance</span><span class="p">()</span>
</pre></div>
</div>
<p>This is a common Python pattern.
By assigning names to intermediate values,
the programmer
— without changing the code’s result —
can pivot between
succinct code that fits on a single line
and more verbose code that names each intermediate value.</p>
<p>Now that we’ve given them names,
we can discuss the three positions:</p>
<ul>
<li><p class="first">A <a class="reference internal" href="api-position.html#skyfield.positionlib.Barycentric" title="skyfield.positionlib.Barycentric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Barycentric</span></code></a> position
measures from the Solar System’s center of mass.
This places its (<em>x,y,z</em>) vector
in the Barycentric Celestial Reference System (BCRS) —
a frame of reference that’s inertial enough
to support the <a class="reference internal" href="api-position.html#skyfield.positionlib.Barycentric.observe" title="skyfield.positionlib.Barycentric.observe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">observe()</span></code></a> method.</p>
<p>You’ll usually start a Skyfield script
by generating a barycentric position
for the <em>center</em> from which you’ll be observing —
whether that’s the Earth,
or a specific location on the Earth’s surface,
or another body like a satellite, planet, or moon.</p>
</li>
<li><p class="first">An <a class="reference internal" href="api-position.html#skyfield.positionlib.Astrometric" title="skyfield.positionlib.Astrometric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Astrometric</span></code></a> position
is returned by the <a class="reference internal" href="api-position.html#skyfield.positionlib.Barycentric.observe" title="skyfield.positionlib.Barycentric.observe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Barycentric.observe()</span></code></a> method which,
given a target you want to observe,
applies the effect of light travel time.
For example,
on Earth we see the Moon where it was about 1.3&nbsp;seconds ago,
the Sun where it was 8&nbsp;minutes ago,
Jupiter where it was more than half an hour ago,
and Neptune where it was about 4&nbsp;hours ago.</p>
</li>
</ul>
<ul>
<li><p class="first">An <a class="reference internal" href="api-position.html#skyfield.positionlib.Apparent" title="skyfield.positionlib.Apparent"><code class="xref py py-class docutils literal notranslate"><span class="pre">Apparent</span></code></a> position is computed
by calling the <a class="reference internal" href="api-position.html#skyfield.positionlib.Astrometric.apparent" title="skyfield.positionlib.Astrometric.apparent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Astrometric.apparent()</span></code></a> method.
This applies two real-world effects
that slightly shift everything in the sky:
the aberration of light
produced by the observer’s own motion through space,
and the gravitational deflection of light
that passes close to masses like the Sun and Jupiter —
and, for an observer on the Earth’s surface,
for deflection produced by the Earth’s own gravity.
The result is an “apparent” position
telling you where the target will really “appear” in tonight’s sky;
it’s the direction you should point your telescope.</p>
<p>When an apparent position is measured from the Earth’s center,
it can be described more formally
as an (<em>x,y,z</em>) position
in Geocentric Celestial Reference System (GCRS) coordinates.</p>
</li>
</ul>
</div>
<div class="section" id="position-attributes">
<h2>Position attributes<a class="headerlink" href="#position-attributes" title="Permalink to this headline">¶</a></h2>
<p>Five basic attributes are available on each position:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">.position</span></code></td>
<td>An (<em>x,y,z</em>) <a class="reference internal" href="api-units.html#skyfield.units.Distance" title="skyfield.units.Distance"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Distance</span></code></a>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">.velocity</span></code></td>
<td>An (<em>x,y,z</em>) <a class="reference internal" href="api-units.html#skyfield.units.Velocity" title="skyfield.units.Velocity"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Velocity</span></code></a>, or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">.t</span></code></td>
<td>The <a class="reference internal" href="api-time.html#skyfield.timelib.Time" title="skyfield.timelib.Time"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Time</span></code></a> of the position, or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">.center</span></code></td>
<td>Body the vector is measured from.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">.target</span></code></td>
<td>Body the vector is measured to.</td>
</tr>
</tbody>
</table>
<p>The first three attributes listed above
are simple instances of Skyfield’s distance, velocity, and time classes,
which you can learn more about
by clicking on their class names.
They support operations like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Earth x,y,z:&#39;</span><span class="p">,</span> <span class="n">barycentric</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">au</span><span class="p">,</span> <span class="s1">&#39;au&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mars relative velocity:&#39;</span><span class="p">,</span> <span class="n">astrometric</span><span class="o">.</span><span class="n">velocity</span><span class="o">.</span><span class="n">km_per_s</span><span class="p">,</span> <span class="s1">&#39;km/s&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Time of observation:&#39;</span><span class="p">,</span> <span class="n">apparent</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">utc_strftime</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Earth x,y,z: [-0.16287311  0.88787399  0.38473904] au
Mars relative velocity: [12.66638873 -8.12551301 -3.38356109] km/s
Time of observation: 1980-01-01 00:00:00 UTC
</pre></div>
</div>
<p>Note that the distance unit attributes
like <code class="docutils literal notranslate"><span class="pre">au</span></code> and <code class="docutils literal notranslate"><span class="pre">km</span></code>
and the velocity unit attributes
like <code class="docutils literal notranslate"><span class="pre">au_per_d</span></code> and <code class="docutils literal notranslate"><span class="pre">km_per_s</span></code>
are each three-element NumPy arrays offering (<em>x,y,z</em>) coordinates.
If the times you’re using are <a class="reference internal" href="time.html#date-arrays"><span class="std std-ref">Date arrays</span></a>,
then the distance and velocity will each have an additional dimension
offering as many (<em>x,y,z</em>) coordinates as there are dates in your array.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.center</span></code> and <code class="docutils literal notranslate"><span class="pre">.target</span></code> attributes require a bit more explanation.
They specify the origin and destination of the vector,
and are displayed if you ask Python to print the vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">apparent</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;Apparent GCRS position and velocity at date t center=399 target=499&gt;
</pre></div>
</div>
<p>In this case our positions were generated from a JPL ephemeris file,
so the center and target are the simple integers
<code class="docutils literal notranslate"><span class="pre">399</span></code> indicating the Earth and <code class="docutils literal notranslate"><span class="pre">499</span></code> indicating Mars.
If instead the center or target were defined by a Skyfield object
like an Earth satellite or latitude-longitude position,
then the <code class="docutils literal notranslate"><span class="pre">.center</span></code> and <code class="docutils literal notranslate"><span class="pre">.target</span></code>
will be those Skyfield objects themselves.</p>
</div>
<div class="section" id="right-ascension-and-declination-astrometric">
<h2>Right ascension and declination: astrometric<a class="headerlink" href="#right-ascension-and-declination-astrometric" title="Permalink to this headline">¶</a></h2>
<p>The most popular coordinate system for star catalogs
treats the night sky as a slowly spinning globe
that we view from the inside.
Just as we specify position on the Earth’s globe
by degrees longitude that you would travel along the equator
and then degrees latitude that you would travel north or south,
coordinates in the sky are measured by two angles.
These are called “equatorial coordinates”
since they are measured with respect to the equator.</p>
<ul>
<li><p class="first"><em>Right ascension</em> (“RA”)
is the sky’s equivalent of longitude,
and is measured east along the celestial equator.
Since the sky makes roughly one complete turn every day,
RA is usually expressed in units of 24&nbsp;hours
rather than 360 degrees.
This supports casual inferences,
like the fact
that a star with an RA of&nbsp;3<sup>h</sup> will climb to your meridian
one hour later than a star with an RA of&nbsp;2<sup>h</sup>.</p>
<p>This coordinate presented astronomers
with the same challenge that longitude presented geographers:
the arbitrary choice of a starting point.
In the case of longitude,
we measure east and west
from the Airy Transit Circle at the Royal Observatory Greenwich.
For RA,
astronomers measure east from the Vernal Equinox,
the point where the Sun crosses the celestial equator in March
as it passes from the southern to the northern half of the sky.</p>
</li>
<li><p class="first"><em>Declination</em> (“Dec”)
is the sky’s equivalent of latitude,
measured north and south of the celestial equator
in degrees, with north being positive.
The North Celestial Pole is at +90°
and the South Celestial Pole is at&nbsp;−90°.</p>
</li>
</ul>
<p>There are two common uses for RA/Dec coordinates.</p>
<p>The first common use is as a reference coordinate system
for perennial knowledge like star charts,
celestial catalogs, and record keeping.
This use case presents two complications.</p>
<p>The first complication
is that real star positions appear to be in constant motion.
The Earth’s revolution around the Sun
moves the stars in little circles thanks to the aberration of light,
and their light can be bent and their images shifted
by the gravity of the Sun, Jupiter, and even the Earth.
Because these effects are periodic or temporary,
they are entirely unsuitable for star charts,
which are supposed to be independent of any particular day of the year.</p>
<p>For this reason,
always generate reference RA/Dec coordinates
from astrometric Skyfield positions,
never from apparent positions.</p>
<p>The second complication is that the Earth’s poles
don’t point in a fixed direction
but gradually trace 26,000-year circles around the sky.
This requires RA/Dec coordinates to specify which year’s “equinox”
their right ascension is measured from,
which will also be the year whose poles and equator they use.</p>
<p>The modern standard for astrometric RA/Dec is the ICRS
(<a class="reference internal" href="#icrs"><span class="std std-ref">described above</span></a>).
With axes that are fixed in the directions of the J2000 equinox and poles,
the ICRS is a permanent coordinate system
that will never suffer precession.
Skyfield returns ICRS coordinates
if you simply call <a class="reference internal" href="api-position.html#skyfield.positionlib.ICRF.radec" title="skyfield.positionlib.ICRF.radec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">radec()</span></code></a>
without an argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Astrometric RA/Dec.</span>
<span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">astrometric</span><span class="o">.</span><span class="n">radec</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;RA:&#39;</span><span class="p">,</span> <span class="n">ra</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dec:&#39;</span><span class="p">,</span> <span class="n">dec</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Distance:&#39;</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RA: 11h 06m 51.22s
Dec: +09deg 05&#39; 09.2&quot;
Distance: 0.96678 au
</pre></div>
</div>
<p>Here we have printed RA and declination using their default units.
See the <a class="reference internal" href="api-units.html#skyfield.units.Angle" title="skyfield.units.Angle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Angle</span></code></a> class documentation
for the attributes and methods
by which you can retrieve and format an angle’s value
in units of your own choice.</p>
<p>If your project specifically requires coordinates
expressed in the RA/Dec of an older equinox,
you can build a time object and pass it to  <a class="reference internal" href="api-position.html#skyfield.positionlib.ICRF.radec" title="skyfield.positionlib.ICRF.radec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">radec()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Astrometric RA/Dec relative to another equinox:</span>
<span class="c1"># the J1991.25 epoch used by the Hipparcos catalog.</span>

<span class="n">equinox</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">J</span><span class="p">(</span><span class="mf">1991.25</span><span class="p">)</span>
<span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">astrometric</span><span class="o">.</span><span class="n">radec</span><span class="p">(</span><span class="n">equinox</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="right-ascension-and-declination-apparent">
<h2>Right ascension and declination: apparent<a class="headerlink" href="#right-ascension-and-declination-apparent" title="Permalink to this headline">¶</a></h2>
<p>The other reason that you might generate RA/Dec is practical:
you are planning to point a telescope,
and after orienting its equatorial mount to the Earth’s poles
you want a declination that stays fixed all night
while your telescope tracks the specified right ascension across the sky.</p>
<p>In this case you aren’t likely to be satisfied
with RA/Dec coordinates of some other era.
You’ll want them measured against where the Earth’s poles
are really pointing tonight.</p>
<p>Skyfield uses the high precision IAU&nbsp;2000A model
to compute both the precession that carries the Earth’s poles
in their 26,000-year circle around the sky
and also the short term wobbles in the Earth’s orientation
that are called nutation.
Together they give Skyfield an accurate assessment
of the direction of the poles and equator
on a given date.</p>
<p>When pointing a telescope,
always use apparent coordinates,
since you will want every possible real-world effect accounted for.</p>
<p>While you could pass each position’s time
to its own <a class="reference internal" href="api-position.html#skyfield.positionlib.ICRF.radec" title="skyfield.positionlib.ICRF.radec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">radec()</span></code></a> method,
that would be a bit tedious,
so Skyfield provides a shortcut:
if you pass the string <code class="docutils literal notranslate"><span class="pre">'date'</span></code>
then the RA/Dec coordinates use the equinox and poles
of the date of the position itself:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apparent RA/Dec.</span>
<span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">apparent</span><span class="o">.</span><span class="n">radec</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;RA:&#39;</span><span class="p">,</span> <span class="n">ra</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dec:&#39;</span><span class="p">,</span> <span class="n">dec</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Distance:&#39;</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RA: 11h 05m 48.68s
Dec: +09deg 11&#39; 35.7&quot;
Distance: 0.96678 au
</pre></div>
</div>
<p>Note that there are two sources of difference
between the astrometric coordinates printed in the previous section
and the apparent coordinates printed here.
We switched to the RA/Dec system of a different year,
so even the exact same position
would have been assigned a different coordinate than before.
But we have also asked for the RA/Dec of a whole different point in the sky:
the point where Mars will actually appear,
not the ideal point where it should sit on a star chart
that ignores aberration and deflection.</p>
</div>
<div class="section" id="azimuth-and-altitude-from-a-geographic-position">
<h2>Azimuth and altitude from a geographic position<a class="headerlink" href="#azimuth-and-altitude-from-a-geographic-position" title="Permalink to this headline">¶</a></h2>
<p>The final result that many users seek
is the altitude and azimuth of an object
above their own local horizon.</p>
<ul class="simple">
<li><em>Altitude</em> measures the angle above or below the horizon.
The zenith is at&nbsp;+90°,
an object on the horizon’s great circle is at&nbsp;0°,
and the nadir beneath your feet is at&nbsp;−90°.</li>
<li><em>Azimuth</em> measures the angle around the sky from the north pole:
0° means exactly north, 90° is east, 180° is south, and 270° is west.</li>
</ul>
<p>Altitude and azimuth are computed
by calling the <a class="reference internal" href="api-position.html#skyfield.positionlib.Apparent.altaz" title="skyfield.positionlib.Apparent.altaz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">altaz()</span></code></a> method on an apparent position.
But because the method needs to know which local horizon to use,
it does not work
on the plain geocentric (“Earth centered”) positions
that we have been generating so far:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">alt</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">apparent</span><span class="o">.</span><span class="n">altaz</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  ...
ValueError: to compute an apparent position, you must observe from a specific Earth location that you specify using a latitude and longitude
</pre></div>
</div>
<p>You can specify a location on Earth
by giving its latitude and longitude
to a standard “geodetic system” that models the Earth’s shape.
The most popular model is WGS84,
used by most modern maps
and also by the Global Positioning System (GPS).
If you are given a longitude and latitude without a datum specified,
they are probably WGS84 coordinates.</p>
<p>You can pass the latitude and longitude to a datum like WGS84
by calling its <a class="reference internal" href="api-topos.html#skyfield.toposlib.Geoid.latlon" title="skyfield.toposlib.Geoid.latlon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">latlon()</span></code></a> method.
Skyfield provides constants <code class="docutils literal notranslate"><span class="pre">N</span></code>, <code class="docutils literal notranslate"><span class="pre">S</span></code>, <code class="docutils literal notranslate"><span class="pre">E</span></code>, and <code class="docutils literal notranslate"><span class="pre">W</span></code>
that are each positive one or negative one,
in case you don’t want to remember which directions are positive.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skyfield.api</span> <span class="kn">import</span> <span class="n">N</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">W</span><span class="p">,</span> <span class="n">wgs84</span>

<span class="c1"># Altitude and azimuth in the sky of a</span>
<span class="c1"># specific geographic location</span>

<span class="n">boston</span> <span class="o">=</span> <span class="n">earth</span> <span class="o">+</span> <span class="n">wgs84</span><span class="o">.</span><span class="n">latlon</span><span class="p">(</span><span class="mf">42.3583</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="mf">71.0603</span> <span class="o">*</span> <span class="n">W</span><span class="p">,</span> <span class="n">elevation_m</span><span class="o">=</span><span class="mi">43</span><span class="p">)</span>
<span class="n">astro</span> <span class="o">=</span> <span class="n">boston</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">utc</span><span class="p">(</span><span class="mi">1980</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">mars</span><span class="p">)</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">astro</span><span class="o">.</span><span class="n">apparent</span><span class="p">()</span>

<span class="n">alt</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">altaz</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">alt</span><span class="o">.</span><span class="n">dstr</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">az</span><span class="o">.</span><span class="n">dstr</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>24deg 30&#39; 27.2&quot;
93deg 04&#39; 29.5&quot;
0.678874 au
</pre></div>
</div>
<p>So Mars was more than 24° above the horizon for Bostonians
on 1980&nbsp;March&nbsp;1 at midnight&nbsp;UTC.</p>
<p>The altitude returned from a plain <a class="reference internal" href="api-position.html#skyfield.positionlib.Apparent.altaz" title="skyfield.positionlib.Apparent.altaz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">altaz()</span></code></a> call
is the ideal position
that you would observe if the Earth had no atmosphere.
You can also ask Skyfield to estimate
where an object might actually appear in the sky
after the Earth’s atmosphere has <em>refracted</em> its image higher.
If you know the weather conditions, you can specify them.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">alt</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">temperature_C</span><span class="o">=</span><span class="mf">15.0</span><span class="p">,</span>
                              <span class="n">pressure_mbar</span><span class="o">=</span><span class="mf">1005.0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">alt</span><span class="o">.</span><span class="n">dstr</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>24deg 32&#39; 34.1&quot;
</pre></div>
</div>
<p>Or you can ask Skyfield to use a standard temperature and pressure
when generating its rough simulation of the effects of refraction.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">alt</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="s1">&#39;standard&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">alt</span><span class="o">.</span><span class="n">dstr</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>24deg 32&#39; 36.4&quot;
</pre></div>
</div>
<p>Keep in mind
that the computed effect of refraction is simply an estimate.
The effects of your local atmosphere,
with its many layers of heat and cold and wind and weather,
cannot be predicted to high precision.
And note that refraction is only applied to objects above the horizon.
Objects below −1.0° altitude are not adjusted for refraction.</p>
</div>
<div class="section" id="comparing-positions">
<h2>Comparing positions<a class="headerlink" href="#comparing-positions" title="Permalink to this headline">¶</a></h2>
<p>If you want to know the angle between two positions in the sky,
call the
<a class="reference internal" href="api-position.html#skyfield.positionlib.ICRF.separation_from" title="skyfield.positionlib.ICRF.separation_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">separation_from()</span></code></a>
method of one of the positions
and pass it the other position as its argument.
The result will be an <a class="reference internal" href="api-units.html#skyfield.units.Angle" title="skyfield.units.Angle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Angle</span></code></a> object.</p>
<p>If instead you want to know the distance between two positions,
subtract the position you want to use as the starting point
from the other position.
The result of this vector math will also itself be a position vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">planets</span><span class="p">[</span><span class="s1">&#39;moon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">planets</span><span class="p">[</span><span class="s1">&#39;earth&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The Moon is </span><span class="si">%d</span><span class="s1"> km away&#39;</span> <span class="o">%</span> <span class="n">v</span><span class="o">.</span><span class="n">distance</span><span class="p">()</span><span class="o">.</span><span class="n">km</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The Moon is 385010 km away
</pre></div>
</div>
<p>Two vectors do not need to have the same date and time to be subtracted.
By comparing two positions with different times,
you can measure how far an object has moved:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">t1</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">utc</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">utc</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>

<span class="n">moon</span> <span class="o">=</span> <span class="n">planets</span><span class="p">[</span><span class="s1">&#39;moon&#39;</span><span class="p">]</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">moon</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">moon</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="n">km</span> <span class="o">=</span> <span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span><span class="o">.</span><span class="n">distance</span><span class="p">()</span><span class="o">.</span><span class="n">km</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In one minute the Moon moved </span><span class="si">%d</span><span class="s1"> km&#39;</span> <span class="o">%</span> <span class="n">km</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>In one minute the Moon moved 1736 km
</pre></div>
</div>
</div>
<div class="section" id="eci-and-ecef-coordinates">
<span id="reference-frames"></span><h2>ECI and ECEF coordinates<a class="headerlink" href="#eci-and-ecef-coordinates" title="Permalink to this headline">¶</a></h2>
<p>Programmers are sometimes asked to produce “ECI” or “ECEF” coordinates,
or to convert between the two.</p>
<p>ECI means <em>Earth-Centered Inertial</em> —
a position centered on the Earth
that’s expressed in a non-rotating reference frame.
Remember the very first coordinates we produced above,
in the <a class="reference internal" href="#barycentric-astrometric-apparent"><span class="std std-ref">Barycentric → Astrometric → Apparent</span></a> section?
They qualify as ECI coordinates!
Why?
Because they’re measured from the Earth’s center,
and because Skyfield’s default ICRS reference frame is inertial.
So when generating positions centered on the Earth,
Skyfield produces ECI coordinates by default.</p>
<p>ECEF means <em>Earth-Centered Earth-Fixed</em> —
a position measured from the Earth’s center
that rotates with the Earth’s surface instead of staying fixed in space.
Skyfield uses the standard ITRS reference frame for Earth-fixed positions.
If all you need are (<em>x,y,z</em>) coordinates,
you can ask Skyfield for them directly.
The ITRS <em>x</em>-axis points at 0° longitude on the Earth’s equator,
the <em>y</em>-axis at 90° east longitude on the equator,
and the <em>z</em>-axis at the North Pole:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skyfield.framelib</span> <span class="kn">import</span> <span class="n">itrs</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">earth</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">moon</span><span class="p">)</span>

<span class="c1"># Cartesian ECEF coordinates.</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">frame_xyz</span><span class="p">(</span><span class="n">itrs</span><span class="p">)</span><span class="o">.</span><span class="n">km</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cartesian (km): x=</span><span class="si">{:.0f}</span><span class="s1"> y=</span><span class="si">{:.0f}</span><span class="s1"> z=</span><span class="si">{:.0f}</span><span class="s1">&#39;</span>
      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Cartesian (km): x=349034 y=-106810 z=122509
</pre></div>
</div>
<p>But ECEF coordinates
are more often expressed using latitude, longitude, and height.
Earlier on this page,
we learned the <a class="reference internal" href="api-topos.html#skyfield.toposlib.Geoid.latlon" title="skyfield.toposlib.Geoid.latlon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">latlon()</span></code></a> method
that takes a latitude and longitude
and returns an ECEF position.
There’s a matching method that goes the other direction,
and computes the latitude and longitude of an existing position.
For example,
we can ask for the Earth longitude and latitude
of the point directly beneath the Moon:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skyfield.api</span> <span class="kn">import</span> <span class="n">wgs84</span>

<span class="c1"># Geographic ECEF coordinates.</span>

<span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">wgs84</span><span class="o">.</span><span class="n">latlon_of</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Latitude: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">degrees</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Longitude: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lon</span><span class="o">.</span><span class="n">degrees</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Latitude: 18.5553
Longitude: -17.0149
</pre></div>
</div>
<p>See the <a class="reference internal" href="api.html#geographic-locations"><span class="std std-ref">Geographic locations</span></a> section
of the API documentation
for the whole slate of methods
that can convert between inertial and Earth-fixed positions.</p>
</div>
<div class="section" id="coordinates-in-other-reference-frames">
<h2>Coordinates in other reference frames<a class="headerlink" href="#coordinates-in-other-reference-frames" title="Permalink to this headline">¶</a></h2>
<p>You can ask Skyfield to express a position
in a number of other reference frames
besides the standard ICRF reference frame
(the modern equivalent to J2000 coordinates)
that Skyfield uses internally.
For example,
to express the position of the Moon relative to the rotating Earth:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skyfield.framelib</span> <span class="kn">import</span> <span class="n">itrs</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">earth</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">planets</span><span class="p">[</span><span class="s1">&#39;moon&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">apparent</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">frame_xyz</span><span class="p">(</span><span class="n">itrs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">km</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[ 349045 -106774  122510]
</pre></div>
</div>
<p>The three position methods that accept a reference frame argument are:</p>
<ul class="simple">
<li><a class="reference internal" href="api-position.html#skyfield.positionlib.ICRF.frame_xyz" title="skyfield.positionlib.ICRF.frame_xyz"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">frame_xyz()</span></code></a></li>
<li><a class="reference internal" href="api-position.html#skyfield.positionlib.ICRF.frame_xyz_and_velocity" title="skyfield.positionlib.ICRF.frame_xyz_and_velocity"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">frame_xyz_and_velocity()</span></code></a></li>
<li><a class="reference internal" href="api-position.html#skyfield.positionlib.ICRF.frame_latlon" title="skyfield.positionlib.ICRF.frame_latlon"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">frame_latlon()</span></code></a></li>
</ul>
<p>Position classes also support a constructor
that accepts a position vector and a velocity vector
in a particular reference frame:</p>
<ul class="simple">
<li><a class="reference internal" href="api-position.html#skyfield.positionlib.ICRF.from_time_and_frame_vectors" title="skyfield.positionlib.ICRF.from_time_and_frame_vectors"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">from_time_and_frame_vectors()</span></code></a></li>
</ul>
<p>Here are the reference frames defined in the <code class="docutils literal notranslate"><span class="pre">framelib</span></code> module
(click on their names for more detailed descriptions):</p>
<ul class="simple">
<li><a class="reference internal" href="api-framelib.html#skyfield.framelib.true_equator_and_equinox_of_date" title="skyfield.framelib.true_equator_and_equinox_of_date"><code class="xref any py py-data docutils literal notranslate"><span class="pre">true_equator_and_equinox_of_date</span></code></a></li>
<li><a class="reference internal" href="api-framelib.html#skyfield.framelib.itrs" title="skyfield.framelib.itrs"><code class="xref any py py-data docutils literal notranslate"><span class="pre">itrs</span></code></a></li>
<li><a class="reference internal" href="api-framelib.html#skyfield.framelib.ecliptic_J2000_frame" title="skyfield.framelib.ecliptic_J2000_frame"><code class="xref py py-data docutils literal notranslate"><span class="pre">ecliptic_J2000_frame</span></code></a></li>
<li><a class="reference internal" href="api-framelib.html#skyfield.framelib.ecliptic_frame" title="skyfield.framelib.ecliptic_frame"><code class="xref py py-data docutils literal notranslate"><span class="pre">ecliptic_frame</span></code></a></li>
<li><a class="reference internal" href="api-framelib.html#skyfield.framelib.galactic_frame" title="skyfield.framelib.galactic_frame"><code class="xref py py-data docutils literal notranslate"><span class="pre">galactic_frame</span></code></a></li>
</ul>
<p>See also <a class="reference internal" href="planetary.html"><span class="doc">Planetary Reference Frames</span></a> for reference frames
that are not included with Skyfield
but that you can load from NASA reference files.</p>
</div>
</div>

  </body>
</html>